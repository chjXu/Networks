# 1.介绍一下dropout和normalization以及他们在训练和预测时的区别，如何解决batch normalization在训练和预测时统计量不一致的问题

  dropout是在alexNet工作提出的，其用于卷积之后，使一部分神经元失活，目的是防止网络过拟合，使网络泛化能力更强。
  normalization是把特征的各个维度标准化到特定区间，其优势为：加快网络训练，提升模型精度
  
  训练和测试的区别：
  
  （1）dropout. 训练时会随机丢弃一些神经元。在测试时往往关闭dropout，目的是保证预测结果的一致性，不关闭可能同一个输入会得到不同的输出。
  为了对齐Dropout训练和预测的结果，通常有两种做法，假设dropout rate = 0.2。一种是训练时不做处理，预测时输出乘以(1 - dropout rate)。
  另一种是训练时留下的神经元除以(1 - dropout rate)，预测时不做处理。
  
  （2）BN在训练时是在每个batch上计算均值和方差来进行归一化，每个batch的样本量都不大，所以每次计算出来的均值和方差就存在差异。
  预测时一般传入一个样本，所以不存在归一化。
  
  通常是通过滑动平均结合训练时所有batch的均值和方差来得到一个总体均值和方差


# 2. L1正则化与L2正则化的区别
  L1减少的是一个常量，L2减少的是权重的固定比例
  
  L1使权重稀疏，L2使权重平滑
  
  L1优点是能够获得sparse模型，对于large-scale的问题来说这一点很重要，因为可以减少存储空间
  
  L2优点是实现简单，能够起到正则化的作用。缺点就是L1的优点：无法获得sparse模型

# 3. new和malloc的区别
  属性:new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持
  
  参数:使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。
  
  返回值：new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
  
  分配内存：new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
  
  自定义类型：new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。
  malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

重载：C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。

内存区域：new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。

# 4. delete的几种方式
  delete 和 delete[]
  
  delete包含两步：（1）析构函数，每个对象各调用一次析构函数；（2）释放内存，内部调用全局的operator delete[](......)函数分配内存；如果类中重载了operator delete[](......)函数，则调用这个重载的函数
